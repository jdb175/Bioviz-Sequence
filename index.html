<!DOCTYPE html>
<meta charset="utf-8">
<style>
</style>
<body>
<!--<script src="http://d3js.org/d3.v3.min.js"></script>-->
<script>
  //http://www.uniprot.org/uniprot/Q197F2
  var sequence1 = "AXXXAAAAAA";
  //http://www.uniprot.org/uniprot/Q197F3
  var sequence2 = "AXABA";
  //http://www.uniprot.org/uniprot/Q91G85
  var sequence3 = "XXX";
  var ret = align(sequence1, sequence2, sequence3);
  console.log(ret[0]+"\n"+ret[1]+"\n"+ret[2]);

  //aligns
  function align(seq1, seq2, seq3) {
    //initialize arrays
    var scores = new Array();
    var residueScore = 7;
    var gapPenalty = -1;
    var misMatchPenalty = -1;
    for(var i = 0; i < seq1.length; ++i) {
      scores[i] = new Array;
      for(var j = 0; j < seq2.length; ++j) {
        scores[i][j] = new Array;
      }
    }

    //set scores
    for(var i = 0; i < seq1.length; ++i) {
      for(var j = 0; j < seq2.length; ++j) {
        for(var k = 0; k < seq3.length; ++k) {
          //Find possible precursor states
          var oldDiag = ( i > 0 && j > 0 && k > 0) ? scores[i-1][j-1][k-1].val : 0, //No gap
              oldGap12 = ( k > 0 ) ? scores[i][j][k-1].val : 0, //There is a gap in seq2&3
              oldGap13 = ( j > 0 ) ? scores[i][j-1][k].val : 0, //There is a gap in seq1&3
              oldGap23 = ( i > 0 ) ? scores[i-1][j][k].val : 0, //There is a gap in seq2&1
              oldGap3 = ( i > 0 && j > 0 ) ? scores[i-1][j-1][k].val : 0, //There is a gap in seq2&3
              oldGap2 = ( i > 0 && k > 0 ) ? scores[i-1][j][k-1].val : 0, //There is a gap in seq1&3
              oldGap1 = ( j > 0 && k > 0 ) ? scores[i][j-1][k-1].val : 0;

          //calculate possible states
          var _12 = (seq1[i] == seq2[j]) ? residueScore : misMatchPenalty,
            _13 = (seq1[i] == seq3[k]) ? residueScore : misMatchPenalty,
            _23 = (seq2[j] == seq3[k]) ? residueScore : misMatchPenalty;

          var diag = oldDiag + _12 + _13 + _23;
            gap1 = oldGap1 + gapPenalty + _23,
            gap2 = oldGap2 + gapPenalty + _13,
            gap3 = oldGap3 + gapPenalty + _12,
            gap12 = oldGap12 + 2*gapPenalty,
            gap23 = oldGap23 + 2*gapPenalty,
            gap13 = oldGap13 + 2*gapPenalty;

          //find the best state
          var max = Math.max(diag, gap1, gap2, gap3, gap12, gap23, gap13);

          if( diag >= max ) {
            scores[i][j][k] ={val: diag, point:"diag"};
          } else if ( gap1 >= max ) {
            scores[i][j][k] ={val: gap1, point:"gap1"};
          } else if ( gap2 >= max ) {
            scores[i][j][k] ={val: gap2, point:"gap2"};
          } else if( gap3 >= max ) {
            scores[i][j][k] ={val: gap3, point:"gap3"};
          } else if( gap13 >= max ) {
            scores[i][j][k] ={val: gap13, point:"gap13"};
          } else if( gap23 >= max ) {
            scores[i][j][k] ={val: gap23, point:"gap23"};
          } else if( gap12 >= max ) {
            scores[i][j][k] ={val: gap12, point:"gap12"};
          }
        }
      }
    }
    
    //Follow array back
    var i = seq1.length-1;
    var j = seq2.length-1;
    var k = seq3.length-1;
    var seq1_a = "";
    var seq2_a = "";
    var seq3_a = "";
    while(i >= 0 && j >= 0 && k >= 0) {
      var cur = scores[i][j][k];
      switch(cur.point) {
        case "diag":
          seq1_a = seq1[i] + seq1_a;
          seq2_a = seq2[j] + seq2_a;
          seq3_a = seq3[k] + seq3_a;
          --i;
          --j;
          --k;
          break;
        case "gap3":
          seq1_a = seq1[i] + seq1_a;
          seq2_a = seq2[j] + seq2_a;
          seq3_a = "_"+seq3_a;
          --i;
          --j;
          break;
        case "gap2":
          seq1_a = seq1[i]+seq1_a;
          seq2_a = "_" + seq2_a;
          seq3_a = seq3[k] + seq3_a;
          --i;
          --k;
          break;
        case "gap1":
          seq1_a = "_" + seq1_a;
          seq2_a = seq2[j] + seq2_a;
          seq3_a = seq3[k] + seq3_a;
          --j;
          --k;
          break;
        case "gap13":
          seq1_a = "_" + seq1_a;
          seq2_a = seq2[j] + seq2_a;
          seq3_a = "_"+seq3_a;
          --j;
          break;
        case "gap23":
          seq1_a = seq1[i]+seq1_a;
          seq2_a = "_" + seq2_a;
          seq3_a = "_" + seq3_a;
          --i;
          break;
        case "gap12":
          seq1_a = "_" + seq1_a;
          seq2_a = "_" + seq2_a;
          seq3_a = seq3[k] + seq3_a;
          --k;
          break;
      }
    }

    //Deal with early ends
    while(i >= 0 || j >= 0 || k >= 0) {
      if(i >= 0) {
        seq1_a = seq1[i] + seq1_a;
        --i;
      } else {
        seq1_a = "_" + seq1_a;
      }
      if(j >= 0) {
        seq2_a = seq2[j] + seq2_a;
        --j;
      } else {
        seq2_a = "_" + seq2_a;
      }
      if(k >= 0) {
        seq3_a = seq3[k] + seq3_a;
        --k;
      } else {
        seq3_a = "_" + seq3_a;
      }
    }
    return([seq1_a, seq2_a, seq3_a])
  }
</script>
